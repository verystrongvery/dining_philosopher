# 📜 **프로젝트 요약**

- 철학자 **(쓰레드 또는 프로세스)** 들이 포크 **(공유자원)** 를 공유하는 상황을 구현
- 자원을 공유하는 상황에서 발생할 수 있는 교착 상태 문제를 해결

# 📅 프로젝트 기간

- 2022.05 ~ 2022.06

# 🫙 Github

- https://github.com/verystrongvery/dining_philosopher

# 🛠 기술 스택

- C, Makefile

# 🛞 발생할 수 있는 교착 상태

- n명의 철학자 (**쓰레드)** 와 n개의 포크 **(공유자원)** 가 주어짐
- 모든 철학자 **(쓰레드)** 는 포크 **(공유자원)** 두 개를 집어야 있어야 식사를 시작 함
- 발생할 수 있는 교착 상태
    - 모든 철학자 **(쓰레드)** 가 왼쪽 포크 **(공유자원)** 를 집었다면, 모든 철학자 **(쓰레드)** 가 오른쪽 포크 **(공유자원)** 를 기다리느라, 모든 철학자 **(쓰레드)** 가 식사를 시작하지 못함
    - 모든 철학자 **(쓰레드)** 는 오른쪽 포크 **(공유자원)** 를 집었다면, 모든 철학자 **(쓰레드)** 가 왼쪽 포크 **(공유자원)** 를 기다리느라, 모든 철학자 **(쓰레드)** 가 식사를 시작하지 못함

# 🖥 **프로젝트 구현 내용**

- 해당 프로젝트는 식사하는 철학자 문제를 3가지 상황으로 구현함
- 식사하는 철학자의 자세한 설명: [https://namu.wiki/w/식사하는 철학자 문제](https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C)

## 1) 첫번째 상황: 멀티 쓰레드 환경에서 뮤텍스로 동기화 처리

### 상황 설명

1. 원형 테이블에 n명의 철학자 **(쓰레드)** 들이 앉아있음
2. 각각의 철학자 **(쓰레드)** 들 사이에 포크 **(공유자원)** 가 1개씩, 총 n개의 포크 **(공유자원)** 가 존재
3. 하나의 포크 **(공유자원)** 마다 하나의 뮤텍스를 걸어 관리
4. 철학자 **(쓰레드)** 옆에 포크 **(공유자원)** 가 존재할 경우. 포크 **(공유자원)** 사용이 가능
5. 모든 철학자 **(쓰레드)** 는 ****포크 **(공유자원)** 두 개를 집어야 있어야 식사를 시작 함

### 구현 내용

1. `pthread_mutex_init` 호출로 n개의 뮤텍스 생성
2. `pthread_create` 호출로 n개의 철학자 **(쓰레드)** 생성
3. 각각의 철학자 **(쓰레드)** 는 포크 **(공유자원)** 를 사용하기전에 `pthread_mutex_lock` 호출
    - 포크 **(공유자원)** 가 사용중이면 뮤텍스가 unlock 상태가 될때까지 대기
4. 각각의 철학자 **(쓰레드)** 는 포크 **(공유자원)** 를 다 사용하면 `pthread_mutex_unlock` 호출
    - 대기 중인 철학자 **(쓰레드)** 가 포크 **(공유자원)** 를 사용

### 교착 상태 방지

- 교착 상태를 방지하기 위해, 포크 **(공유 자원)** 의 할당 순서를 조절함
    - 처음에 철학자 **(쓰레드)** 들이 포크 **(공유자원)** 를 집어들때, 홀수 번째 철학자 **(쓰레드)** 에서 `usleep`을 호출하여 임계구역에 늦게 진입 하도록 만듬
- 결과적으로 교착 상태의 발생 조건 4가지(상호 배제, 점유 대기, 비 선점, 순환성 대기) 중 순환성 대기 조건이 발생하지 않게 되어 교착 상태가 발생하지 않게 됨

## 2) 두번째 상황: 멀티 쓰레드 환경에서 세마포어로 동기화 처리

### 상황 설명

1. 원형 테이블에 n명의 철학자 **(쓰레드)** 들이 앉아있음
2. n개의 포크 **(공유자원)** 가 테이블 중간에 위치
3. 세마포어가 모든 포크 **(공유자원)** 를 관리
4. 테이블 중간에 포크 **(공유자원)**가 존재할 경우, 포크 **(공유자원)** 사용이 가능
5. 모든 철학자 **(쓰레드)** 는 포크 **(공유자원)** 두 개를 집어야 있어야 식사를 시작 함

### 구현 내용

1. `sem_open` 함수 호출로 세마포어 생성
2. `pthread_create` 함수 호출로 n개의 **철학자 (쓰레드)** 생성
3. 각각의 철학자 **(쓰레드)**는 포크 **(공유자원)** 를 사용하기전에 `sem_wait` 호출
    - 세마포어 수가 0이 아니면 세마포어 수가 0이 될 때까지 대기
4. 각각의 철학자 **(쓰레드)** 는 포크 **(공유자원)** 를 다 사용하면 `sem_post` 호출
    - 대기 중인 철학자 **(쓰레드)** 가 포크 **(공유자원)**를 사용

### 교착 상태 방지

- 교착 상태를 방지하기 위해, 철학자 **(쓰레드)** 들이 양쪽 포크 **(공유자원)** 를 한번에 집어 들도록 만듬
    - 세마포어 수 1은 포크 **(공유자원)** 2개를 의미
- 결과적으로 교착 상태의 발생 조건 4가지(상호 배제, 점유 대기, 비 선점, 순환성 대기) 중 순환성 대기 조건이 발생하지 않게 되어 교착 상태가 발생하지 않게 됨

## 세번째 상황: 멀티 프로세스 환경에서 세마포어로 동기화 처리

- 두 번째 상황과 동일하나, 철학자가 쓰레드가 아닌 프로세스가 되도록 구현
